---
id: 11
title: 数据库事务的几个概念
date: 2013-10-10T20:15:03+00:00
author: 李朝
layout: post
guid: http://www.lizhaoblog.com/?p=11
permalink: /archives/11
categories:
  - 数据库
tags:
  - 数据库
---
**1，第一类丢失更新；2，脏读；3，虚读；4，不可重复读；5，第二类丢失更新；**

1、第一类丢失更新（lost update）：

事务1、2同时开启，同时读取数据，事务2修改数据后先提交，然后事物1修改数据后回滚。结果事务1回滚了事务2的操作，导致事务2的修改操作丢失。

2，脏读（dirty   reads）：

事务1先开启事务读取了数据，然后进行了修改未提交。此时事务2开启，读取了事务1未提交的数据，此时事务1回滚，然后事务2提交。结果事务2的提交把事务1回滚的操作丢失了。

3，虚读（幻读）（phantom   reads）：

事务1开启读取了数据未提交。此时事务2开启，并进行了数据插入或者删除操作，然后提交。此时事务2再次读取数据，发现与先前的数据不一致

4、不可重复读（** **non-repeatable   reads）：

事务1开启读取了数据未提交，然后事务2开启并对事务1读取的数据进行了修改（不知道删除算不算），然后事务2提交。此时事务1再次读取数据时发现与开始读取的数据不一致。

*这里不可重复读与虚读有点混乱，我个人感觉虚读是读取的结果是一个结果集可能是很多条的记录，第二次读取时候结果集的数据增加了一些新的内容或者比第一次读取的数据少了，因为被另外一个事务做了插入新数据或者删除了老数据操作；而不可重复读则是读取到了某一条记录，第二次读取的与第一次读取的数据内容不一致，因为被另外一个事务修改了。两者的侧重点不同，虚读侧重表，而不可重复读侧重行；虚读侧重添加或删除，不可重复读侧重修改。

不可重复读和脏读也有些相似之处，都是读取到了另外一个事务修改的数据，但是不可重复读是读取两次，第二次读取到的是另外一个事务已经提交了的，而脏读确实读取到另外一个事务未提交前的数据，且把另外一个已提交的事务给覆盖了造成数据有丢失。

5，第二类丢失更新：

在不可重复读中，事务1的第二次读取未发生，而是直接或者做了其他修改操作提交了，导致事务2的修改操作丢失了，数据回到开始前的数据。

个人感觉与第一类的区别为一个是修改回滚，一个是又或者没有修改然后提交。

举例：

对于同一个银行帐户A内有200元，甲进行提款操作100元，乙进行转帐操作100元到B帐户。如果事务没有进行隔离可能会并发如下问题：
  
1、第一类丢失更新：首先甲提款时帐户内有200元，同时乙转帐也是200元，然后甲乙同时操作，甲操作成功取走100元，乙操作失败回滚，帐户内最终为200元，这样甲的操作被覆盖掉了，银行损失100元。
  
2、脏读：甲取款100元未提交，乙进行转帐查到帐户内剩有100元，这是甲放弃操作回滚，乙正常操作提交，帐户内最终为0元，乙读取了甲的脏数据，客户损失100元。
  
3、虚读：和脏读类似，是针对于插入操作过程中的读取问题，如丙存款100元未提交，这时银行做报表进行统计查询帐户为200元，然后丙提交了，这时银行再统计发现帐户为300元了，无法判断到底以哪个为准？
  
大家好像觉得统计这个东西肯定是时时更新的，这种情况很正常；但是如果统计是在一个事务中的时候就不正常了，比如我们的一个统计应用需要将统计结果分别输出到电脑屏幕和远程网络某台计算机的磁盘文件中，为了
  
提高性能和用户响应我们分成2个线程，这时先完成的和后完成的统计数据就可能不一致，我们就不知道以哪个为准了。
  
4、不可重复读：甲乙同时开始都查到帐户内为200元，甲先开始取款100元提交，这时乙在准备最后更新的时候又进行了一次查询，发现结果是100元，这时乙就会很困惑，不知道该将帐户改为100还是0。
  
和脏读的区别是，脏读是读取前一事务未提交的脏数据，不可重复读是重新读取了前一事务已提交的数据。
  
5、第二类丢失更新：是不可重复读的一种特例，如上，乙不做第二次查询而是直接操作完成，帐户内最终为200元；或者是乙存了100元提交，最终账户内为300元。甲的操作被覆盖掉了，银行损失100元。

**锁：**

x锁（eXclusive lock） 排他锁/写锁： 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象

s锁（Share lock） 共享锁/读锁： 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加s锁。

(U) 锁 更新锁：可以防止通常形式的死锁。一般更新模式由一个事务组成，此事务读取记录，获取资源（页或行）的共享 (S) 锁，然后修改行，此操作要求锁转换为排它 (X) 锁。如果两个事务获得了资源上的共享模式锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它 (X) 锁。共享模式到排它锁的转换必须等待一段时间，因为一个事务的排它锁与其它事务的共享模式锁不兼容；发生锁等待。第二个事务试图获取排它 (X) 锁以进行更新。由于两个事务都要转换为排它 (X) 锁，并且每个事务都等待另一个事务释放共享模式锁，因此发生死锁。

**封锁协议：**
  
一级封锁协议：
  
在事务修改数据的时候加x锁，直到事务结束（提交或者回滚）释放x锁。一级封锁协议可以有效的防止丢失更新，但是不能防止脏读不可重复读的出现。
  
二级封锁协议：
  
在一级封锁的基础上事务读数据的时候加s锁，读取之后释放。二级封锁协议可以防止丢失更新，脏读。不能防止不可重复读。
  
三级封锁协议：
  
在一级封锁的基础上事务读数据的时候加s锁，直到事务结束释放。二级封锁协议可以防止丢失更新，脏读，不可重复读。

参考:[多角度彻底理解数据库事务中的”脏读”.”不可重复的读”及”虚读”](http://www.blogjava.net/zhengtengfeng/archive/2007/04/23/113025.html){#viewpost1_TitleUrl}

[Hibernate事务与并发问题处理（乐观锁与悲观锁）](http://www.cnblogs.com/otomedaybreak/archive/2012/01/27/2330008.html){#cb_post_title_url}